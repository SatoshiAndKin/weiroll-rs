/**

Generated by the following Solidity interface...
```solidity
interface CommandBuilderHarness {
    function basecall() external pure;
    function testBuildInputs(bytes[] memory state, bytes4 selector, bytes32 indices) external view returns (bytes memory);
    function testBuildInputsBaseGas(bytes[] memory state, bytes4 selector, bytes32 indices) external view returns (bytes memory out);
    function testWriteOutputs(bytes[] memory state, bytes1 index, bytes memory output) external pure returns (bytes[] memory, bytes memory);
    function testWriteOutputsBaseGas(bytes[] memory state, bytes1 index, bytes memory output) external pure returns (bytes[] memory, bytes memory);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "basecall",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "testBuildInputs",
    "inputs": [
      {
        "name": "state",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "selector",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "indices",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "testBuildInputsBaseGas",
    "inputs": [
      {
        "name": "state",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "selector",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "indices",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "testWriteOutputs",
    "inputs": [
      {
        "name": "state",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "index",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "output",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "testWriteOutputsBaseGas",
    "inputs": [
      {
        "name": "state",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "index",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "output",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod CommandBuilderHarness {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b5061115b8061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610055575f3560e01c8063171f98cb146100595780637f1803211461008a5780637ff6f34f146100bb578063a402609a146100eb578063edff49f71461011b575b5f5ffd5b610073600480360381019061006e91906108fb565b610125565b604051610081929190610ae6565b60405180910390f35b6100a4600480360381019061009f91906108fb565b61014d565b6040516100b2929190610ae6565b60405180910390f35b6100d560048036038101906100d09190610ba3565b6101ab565b6040516100e29190610c0f565b60405180910390f35b61010560048036038101906101009190610ba3565b6101d0565b6040516101129190610c0f565b60405180910390f35b6101236101d9565b005b60608061013d8484876101db9092919063ffffffff16565b9450848391509150935093915050565b60608084602067ffffffffffffffff81111561016c5761016b61069c565b5b6040519080825280601f01601f19166020018201604052801561019e5781602001600182028036833780820191505090505b5091509150935093915050565b60605f6101c38484876103059092919063ffffffff16565b9050809150509392505050565b60609392505050565b565b60605f8360f81c60ff16905060ff81036101f857849150506102fe565b5f60808216146102925760fe8103610225578280602001905181019061021e9190610d50565b945061028d565b5f6020840151905060208114610270576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161026790610e17565b60405180910390fd5b60208451036020850152602084016020607f841602602088010152505b6102f9565b60208351146102d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102cd90610ea5565b60405180910390fd5b8285607f8316815181106102ed576102ec610ec3565b5b60200260200101819052505b849150505b9392505050565b60605f5f60605f5f5b60208110156104a35786816020811061032a57610329610ec3565b5b1a60f81b60f81c60ff16915060ff8203156104a3575f60808316146104215760fe8203610390575f83510361037c578860405160200161036a9190610ef0565b60405160208183030381529060405292505b8251856103899190610f46565b945061041c565b5f89607f8416815181106103a7576103a6610ec3565b5b60200260200101515190505f6020826103c09190610fa6565b14610400576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103f790611046565b60405180910390fd5b60208161040d9190610f46565b866104189190610f46565b9550505b610492565b602089607f84168151811061043957610438610ec3565b5b60200260200101515114610482576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610479906110d4565b60405180910390fd5b60208561048f9190610f46565b94505b60208401935080600101905061030e565b506004846104b19190610f46565b67ffffffffffffffff8111156104ca576104c961069c565b5b6040519080825280601f01601f1916602001820160405280156104fc5781602001600182028036833780820191505090505b5094508660208601525f93505f5b60208110156106515786816020811061052657610525610ec3565b5b1a60f81b60f81c60ff16915060ff820315610651575f60808316146106115760fe820361059c57838560248801015261057c836020886004886105699190610f46565b6020885161057791906110f2565b61065d565b6020835161058a91906110f2565b846105959190610f46565b935061060c565b5f89607f8416815181106105b3576105b2610ec3565b5b602002602001015151905084866024890101526105fc8a607f8516815181106105df576105de610ec3565b5b60200260200101515f896004896105f69190610f46565b8561065d565b80856106089190610f46565b9450505b610640565b5f89607f84168151811061062857610627610ec3565b5b60200260200101519050602081015186602489010152505b60208501945080600101905061050a565b50505050509392505050565b808260208501018286602089010160045afa505050505050565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6106d28261068c565b810181811067ffffffffffffffff821117156106f1576106f061069c565b5b80604052505050565b5f610703610677565b905061070f82826106c9565b919050565b5f67ffffffffffffffff82111561072e5761072d61069c565b5b602082029050602081019050919050565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff8211156107615761076061069c565b5b61076a8261068c565b9050602081019050919050565b828183375f83830152505050565b5f61079761079284610747565b6106fa565b9050828152602081018484840111156107b3576107b2610743565b5b6107be848285610777565b509392505050565b5f82601f8301126107da576107d9610688565b5b81356107ea848260208601610785565b91505092915050565b5f61080561080084610714565b6106fa565b905080838252602082019050602084028301858111156108285761082761073f565b5b835b8181101561086f57803567ffffffffffffffff81111561084d5761084c610688565b5b80860161085a89826107c6565b8552602085019450505060208101905061082a565b5050509392505050565b5f82601f83011261088d5761088c610688565b5b813561089d8482602086016107f3565b91505092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b6108da816108a6565b81146108e4575f5ffd5b50565b5f813590506108f5816108d1565b92915050565b5f5f5f6060848603121561091257610911610680565b5b5f84013567ffffffffffffffff81111561092f5761092e610684565b5b61093b86828701610879565b935050602061094c868287016108e7565b925050604084013567ffffffffffffffff81111561096d5761096c610684565b5b610979868287016107c6565b9150509250925092565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f6109de826109ac565b6109e881856109b6565b93506109f88185602086016109c6565b610a018161068c565b840191505092915050565b5f610a1783836109d4565b905092915050565b5f602082019050919050565b5f610a3582610983565b610a3f818561098d565b935083602082028501610a518561099d565b805f5b85811015610a8c5784840389528151610a6d8582610a0c565b9450610a7883610a1f565b925060208a01995050600181019050610a54565b50829750879550505050505092915050565b5f82825260208201905092915050565b5f610ab8826109ac565b610ac28185610a9e565b9350610ad28185602086016109c6565b610adb8161068c565b840191505092915050565b5f6040820190508181035f830152610afe8185610a2b565b90508181036020830152610b128184610aae565b90509392505050565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b610b4f81610b1b565b8114610b59575f5ffd5b50565b5f81359050610b6a81610b46565b92915050565b5f819050919050565b610b8281610b70565b8114610b8c575f5ffd5b50565b5f81359050610b9d81610b79565b92915050565b5f5f5f60608486031215610bba57610bb9610680565b5b5f84013567ffffffffffffffff811115610bd757610bd6610684565b5b610be386828701610879565b9350506020610bf486828701610b5c565b9250506040610c0586828701610b8f565b9150509250925092565b5f6020820190508181035f830152610c278184610aae565b905092915050565b5f610c41610c3c84610747565b6106fa565b905082815260208101848484011115610c5d57610c5c610743565b5b610c688482856109c6565b509392505050565b5f82601f830112610c8457610c83610688565b5b8151610c94848260208601610c2f565b91505092915050565b5f610caf610caa84610714565b6106fa565b90508083825260208201905060208402830185811115610cd257610cd161073f565b5b835b81811015610d1957805167ffffffffffffffff811115610cf757610cf6610688565b5b808601610d048982610c70565b85526020850194505050602081019050610cd4565b5050509392505050565b5f82601f830112610d3757610d36610688565b5b8151610d47848260208601610c9d565b91505092915050565b5f60208284031215610d6557610d64610680565b5b5f82015167ffffffffffffffff811115610d8257610d81610684565b5b610d8e84828501610d23565b91505092915050565b5f82825260208201905092915050565b7f4f6e6c79206f6e652072657475726e2076616c7565207065726d6974746564205f8201527f287661726961626c652900000000000000000000000000000000000000000000602082015250565b5f610e01602a83610d97565b9150610e0c82610da7565b604082019050919050565b5f6020820190508181035f830152610e2e81610df5565b9050919050565b7f4f6e6c79206f6e652072657475726e2076616c7565207065726d6974746564205f8201527f2873746174696329000000000000000000000000000000000000000000000000602082015250565b5f610e8f602883610d97565b9150610e9a82610e35565b604082019050919050565b5f6020820190508181035f830152610ebc81610e83565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f6020820190508181035f830152610f088184610a2b565b905092915050565b5f819050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610f5082610f10565b9150610f5b83610f10565b9250828201905080821115610f7357610f72610f19565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f610fb082610f10565b9150610fbb83610f10565b925082610fcb57610fca610f79565b5b828206905092915050565b7f44796e616d6963207374617465207661726961626c6573206d757374206265205f8201527f61206d756c7469706c65206f6620333220627974657300000000000000000000602082015250565b5f611030603683610d97565b915061103b82610fd6565b604082019050919050565b5f6020820190508181035f83015261105d81611024565b9050919050565b7f537461746963207374617465207661726961626c6573206d75737420626520335f8201527f3220627974657300000000000000000000000000000000000000000000000000602082015250565b5f6110be602783610d97565b91506110c982611064565b604082019050919050565b5f6020820190508181035f8301526110eb816110b2565b9050919050565b5f6110fc82610f10565b915061110783610f10565b925082820390508181111561111f5761111e610f19565b5b9291505056fea26469706673582212200a468309572a2a135fa5515616f54534376474a0e8717dc15e60aead1284d59264736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x11[\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0UW_5`\xE0\x1C\x80c\x17\x1F\x98\xCB\x14a\0YW\x80c\x7F\x18\x03!\x14a\0\x8AW\x80c\x7F\xF6\xF3O\x14a\0\xBBW\x80c\xA4\x02`\x9A\x14a\0\xEBW\x80c\xED\xFFI\xF7\x14a\x01\x1BW[__\xFD[a\0s`\x04\x806\x03\x81\x01\x90a\0n\x91\x90a\x08\xFBV[a\x01%V[`@Qa\0\x81\x92\x91\x90a\n\xE6V[`@Q\x80\x91\x03\x90\xF3[a\0\xA4`\x04\x806\x03\x81\x01\x90a\0\x9F\x91\x90a\x08\xFBV[a\x01MV[`@Qa\0\xB2\x92\x91\x90a\n\xE6V[`@Q\x80\x91\x03\x90\xF3[a\0\xD5`\x04\x806\x03\x81\x01\x90a\0\xD0\x91\x90a\x0B\xA3V[a\x01\xABV[`@Qa\0\xE2\x91\x90a\x0C\x0FV[`@Q\x80\x91\x03\x90\xF3[a\x01\x05`\x04\x806\x03\x81\x01\x90a\x01\0\x91\x90a\x0B\xA3V[a\x01\xD0V[`@Qa\x01\x12\x91\x90a\x0C\x0FV[`@Q\x80\x91\x03\x90\xF3[a\x01#a\x01\xD9V[\0[``\x80a\x01=\x84\x84\x87a\x01\xDB\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x94P\x84\x83\x91P\x91P\x93P\x93\x91PPV[``\x80\x84` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x01lWa\x01ka\x06\x9CV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x01\x9EW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x91P\x91P\x93P\x93\x91PPV[``_a\x01\xC3\x84\x84\x87a\x03\x05\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x90P\x80\x91PP\x93\x92PPPV[``\x93\x92PPPV[V[``_\x83`\xF8\x1C`\xFF\x16\x90P`\xFF\x81\x03a\x01\xF8W\x84\x91PPa\x02\xFEV[_`\x80\x82\x16\x14a\x02\x92W`\xFE\x81\x03a\x02%W\x82\x80` \x01\x90Q\x81\x01\x90a\x02\x1E\x91\x90a\rPV[\x94Pa\x02\x8DV[_` \x84\x01Q\x90P` \x81\x14a\x02pW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02g\x90a\x0E\x17V[`@Q\x80\x91\x03\x90\xFD[` \x84Q\x03` \x85\x01R` \x84\x01` `\x7F\x84\x16\x02` \x88\x01\x01RP[a\x02\xF9V[` \x83Q\x14a\x02\xD6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02\xCD\x90a\x0E\xA5V[`@Q\x80\x91\x03\x90\xFD[\x82\x85`\x7F\x83\x16\x81Q\x81\x10a\x02\xEDWa\x02\xECa\x0E\xC3V[[` \x02` \x01\x01\x81\x90RP[\x84\x91PP[\x93\x92PPPV[``__``__[` \x81\x10\x15a\x04\xA3W\x86\x81` \x81\x10a\x03*Wa\x03)a\x0E\xC3V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16\x91P`\xFF\x82\x03\x15a\x04\xA3W_`\x80\x83\x16\x14a\x04!W`\xFE\x82\x03a\x03\x90W_\x83Q\x03a\x03|W\x88`@Q` \x01a\x03j\x91\x90a\x0E\xF0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x92P[\x82Q\x85a\x03\x89\x91\x90a\x0FFV[\x94Pa\x04\x1CV[_\x89`\x7F\x84\x16\x81Q\x81\x10a\x03\xA7Wa\x03\xA6a\x0E\xC3V[[` \x02` \x01\x01QQ\x90P_` \x82a\x03\xC0\x91\x90a\x0F\xA6V[\x14a\x04\0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03\xF7\x90a\x10FV[`@Q\x80\x91\x03\x90\xFD[` \x81a\x04\r\x91\x90a\x0FFV[\x86a\x04\x18\x91\x90a\x0FFV[\x95PP[a\x04\x92V[` \x89`\x7F\x84\x16\x81Q\x81\x10a\x049Wa\x048a\x0E\xC3V[[` \x02` \x01\x01QQ\x14a\x04\x82W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04y\x90a\x10\xD4V[`@Q\x80\x91\x03\x90\xFD[` \x85a\x04\x8F\x91\x90a\x0FFV[\x94P[` \x84\x01\x93P\x80`\x01\x01\x90Pa\x03\x0EV[P`\x04\x84a\x04\xB1\x91\x90a\x0FFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x04\xCAWa\x04\xC9a\x06\x9CV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x04\xFCW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x94P\x86` \x86\x01R_\x93P_[` \x81\x10\x15a\x06QW\x86\x81` \x81\x10a\x05&Wa\x05%a\x0E\xC3V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16\x91P`\xFF\x82\x03\x15a\x06QW_`\x80\x83\x16\x14a\x06\x11W`\xFE\x82\x03a\x05\x9CW\x83\x85`$\x88\x01\x01Ra\x05|\x83` \x88`\x04\x88a\x05i\x91\x90a\x0FFV[` \x88Qa\x05w\x91\x90a\x10\xF2V[a\x06]V[` \x83Qa\x05\x8A\x91\x90a\x10\xF2V[\x84a\x05\x95\x91\x90a\x0FFV[\x93Pa\x06\x0CV[_\x89`\x7F\x84\x16\x81Q\x81\x10a\x05\xB3Wa\x05\xB2a\x0E\xC3V[[` \x02` \x01\x01QQ\x90P\x84\x86`$\x89\x01\x01Ra\x05\xFC\x8A`\x7F\x85\x16\x81Q\x81\x10a\x05\xDFWa\x05\xDEa\x0E\xC3V[[` \x02` \x01\x01Q_\x89`\x04\x89a\x05\xF6\x91\x90a\x0FFV[\x85a\x06]V[\x80\x85a\x06\x08\x91\x90a\x0FFV[\x94PP[a\x06@V[_\x89`\x7F\x84\x16\x81Q\x81\x10a\x06(Wa\x06'a\x0E\xC3V[[` \x02` \x01\x01Q\x90P` \x81\x01Q\x86`$\x89\x01\x01RP[` \x85\x01\x94P\x80`\x01\x01\x90Pa\x05\nV[PPPPP\x93\x92PPPV[\x80\x82` \x85\x01\x01\x82\x86` \x89\x01\x01`\x04Z\xFAPPPPPPV[_`@Q\x90P\x90V[__\xFD[__\xFD[__\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x06\xD2\x82a\x06\x8CV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x06\xF1Wa\x06\xF0a\x06\x9CV[[\x80`@RPPPV[_a\x07\x03a\x06wV[\x90Pa\x07\x0F\x82\x82a\x06\xC9V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x07.Wa\x07-a\x06\x9CV[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x07aWa\x07`a\x06\x9CV[[a\x07j\x82a\x06\x8CV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a\x07\x97a\x07\x92\x84a\x07GV[a\x06\xFAV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a\x07\xB3Wa\x07\xB2a\x07CV[[a\x07\xBE\x84\x82\x85a\x07wV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x07\xDAWa\x07\xD9a\x06\x88V[[\x815a\x07\xEA\x84\x82` \x86\x01a\x07\x85V[\x91PP\x92\x91PPV[_a\x08\x05a\x08\0\x84a\x07\x14V[a\x06\xFAV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x08(Wa\x08'a\x07?V[[\x83[\x81\x81\x10\x15a\x08oW\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x08MWa\x08La\x06\x88V[[\x80\x86\x01a\x08Z\x89\x82a\x07\xC6V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa\x08*V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x08\x8DWa\x08\x8Ca\x06\x88V[[\x815a\x08\x9D\x84\x82` \x86\x01a\x07\xF3V[\x91PP\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a\x08\xDA\x81a\x08\xA6V[\x81\x14a\x08\xE4W__\xFD[PV[_\x815\x90Pa\x08\xF5\x81a\x08\xD1V[\x92\x91PPV[___``\x84\x86\x03\x12\x15a\t\x12Wa\t\x11a\x06\x80V[[_\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\t/Wa\t.a\x06\x84V[[a\t;\x86\x82\x87\x01a\x08yV[\x93PP` a\tL\x86\x82\x87\x01a\x08\xE7V[\x92PP`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\tmWa\tla\x06\x84V[[a\ty\x86\x82\x87\x01a\x07\xC6V[\x91PP\x92P\x92P\x92V[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_a\t\xDE\x82a\t\xACV[a\t\xE8\x81\x85a\t\xB6V[\x93Pa\t\xF8\x81\x85` \x86\x01a\t\xC6V[a\n\x01\x81a\x06\x8CV[\x84\x01\x91PP\x92\x91PPV[_a\n\x17\x83\x83a\t\xD4V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\n5\x82a\t\x83V[a\n?\x81\x85a\t\x8DV[\x93P\x83` \x82\x02\x85\x01a\nQ\x85a\t\x9DV[\x80_[\x85\x81\x10\x15a\n\x8CW\x84\x84\x03\x89R\x81Qa\nm\x85\x82a\n\x0CV[\x94Pa\nx\x83a\n\x1FV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pa\nTV[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a\n\xB8\x82a\t\xACV[a\n\xC2\x81\x85a\n\x9EV[\x93Pa\n\xD2\x81\x85` \x86\x01a\t\xC6V[a\n\xDB\x81a\x06\x8CV[\x84\x01\x91PP\x92\x91PPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ra\n\xFE\x81\x85a\n+V[\x90P\x81\x81\x03` \x83\x01Ra\x0B\x12\x81\x84a\n\xAEV[\x90P\x93\x92PPPV[_\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a\x0BO\x81a\x0B\x1BV[\x81\x14a\x0BYW__\xFD[PV[_\x815\x90Pa\x0Bj\x81a\x0BFV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x0B\x82\x81a\x0BpV[\x81\x14a\x0B\x8CW__\xFD[PV[_\x815\x90Pa\x0B\x9D\x81a\x0ByV[\x92\x91PPV[___``\x84\x86\x03\x12\x15a\x0B\xBAWa\x0B\xB9a\x06\x80V[[_\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0B\xD7Wa\x0B\xD6a\x06\x84V[[a\x0B\xE3\x86\x82\x87\x01a\x08yV[\x93PP` a\x0B\xF4\x86\x82\x87\x01a\x0B\\V[\x92PP`@a\x0C\x05\x86\x82\x87\x01a\x0B\x8FV[\x91PP\x92P\x92P\x92V[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0C'\x81\x84a\n\xAEV[\x90P\x92\x91PPV[_a\x0CAa\x0C<\x84a\x07GV[a\x06\xFAV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a\x0C]Wa\x0C\\a\x07CV[[a\x0Ch\x84\x82\x85a\t\xC6V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x0C\x84Wa\x0C\x83a\x06\x88V[[\x81Qa\x0C\x94\x84\x82` \x86\x01a\x0C/V[\x91PP\x92\x91PPV[_a\x0C\xAFa\x0C\xAA\x84a\x07\x14V[a\x06\xFAV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x0C\xD2Wa\x0C\xD1a\x07?V[[\x83[\x81\x81\x10\x15a\r\x19W\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C\xF7Wa\x0C\xF6a\x06\x88V[[\x80\x86\x01a\r\x04\x89\x82a\x0CpV[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa\x0C\xD4V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\r7Wa\r6a\x06\x88V[[\x81Qa\rG\x84\x82` \x86\x01a\x0C\x9DV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a\reWa\rda\x06\x80V[[_\x82\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\x82Wa\r\x81a\x06\x84V[[a\r\x8E\x84\x82\x85\x01a\r#V[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOnly one return value permitted _\x82\x01R\x7F(variable)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0E\x01`*\x83a\r\x97V[\x91Pa\x0E\x0C\x82a\r\xA7V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0E.\x81a\r\xF5V[\x90P\x91\x90PV[\x7FOnly one return value permitted _\x82\x01R\x7F(static)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0E\x8F`(\x83a\r\x97V[\x91Pa\x0E\x9A\x82a\x0E5V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0E\xBC\x81a\x0E\x83V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0F\x08\x81\x84a\n+V[\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x0FP\x82a\x0F\x10V[\x91Pa\x0F[\x83a\x0F\x10V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\x0FsWa\x0Fra\x0F\x19V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a\x0F\xB0\x82a\x0F\x10V[\x91Pa\x0F\xBB\x83a\x0F\x10V[\x92P\x82a\x0F\xCBWa\x0F\xCAa\x0FyV[[\x82\x82\x06\x90P\x92\x91PPV[\x7FDynamic state variables must be _\x82\x01R\x7Fa multiple of 32 bytes\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x100`6\x83a\r\x97V[\x91Pa\x10;\x82a\x0F\xD6V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x10]\x81a\x10$V[\x90P\x91\x90PV[\x7FStatic state variables must be 3_\x82\x01R\x7F2 bytes\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x10\xBE`'\x83a\r\x97V[\x91Pa\x10\xC9\x82a\x10dV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x10\xEB\x81a\x10\xB2V[\x90P\x91\x90PV[_a\x10\xFC\x82a\x0F\x10V[\x91Pa\x11\x07\x83a\x0F\x10V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a\x11\x1FWa\x11\x1Ea\x0F\x19V[[\x92\x91PPV\xFE\xA2dipfsX\"\x12 \nF\x83\tW**\x13_\xA5QV\x16\xF5E47dt\xA0\xE8q}\xC1^`\xAE\xAD\x12\x84\xD5\x92dsolcC\0\x08\x1E\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610055575f3560e01c8063171f98cb146100595780637f1803211461008a5780637ff6f34f146100bb578063a402609a146100eb578063edff49f71461011b575b5f5ffd5b610073600480360381019061006e91906108fb565b610125565b604051610081929190610ae6565b60405180910390f35b6100a4600480360381019061009f91906108fb565b61014d565b6040516100b2929190610ae6565b60405180910390f35b6100d560048036038101906100d09190610ba3565b6101ab565b6040516100e29190610c0f565b60405180910390f35b61010560048036038101906101009190610ba3565b6101d0565b6040516101129190610c0f565b60405180910390f35b6101236101d9565b005b60608061013d8484876101db9092919063ffffffff16565b9450848391509150935093915050565b60608084602067ffffffffffffffff81111561016c5761016b61069c565b5b6040519080825280601f01601f19166020018201604052801561019e5781602001600182028036833780820191505090505b5091509150935093915050565b60605f6101c38484876103059092919063ffffffff16565b9050809150509392505050565b60609392505050565b565b60605f8360f81c60ff16905060ff81036101f857849150506102fe565b5f60808216146102925760fe8103610225578280602001905181019061021e9190610d50565b945061028d565b5f6020840151905060208114610270576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161026790610e17565b60405180910390fd5b60208451036020850152602084016020607f841602602088010152505b6102f9565b60208351146102d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102cd90610ea5565b60405180910390fd5b8285607f8316815181106102ed576102ec610ec3565b5b60200260200101819052505b849150505b9392505050565b60605f5f60605f5f5b60208110156104a35786816020811061032a57610329610ec3565b5b1a60f81b60f81c60ff16915060ff8203156104a3575f60808316146104215760fe8203610390575f83510361037c578860405160200161036a9190610ef0565b60405160208183030381529060405292505b8251856103899190610f46565b945061041c565b5f89607f8416815181106103a7576103a6610ec3565b5b60200260200101515190505f6020826103c09190610fa6565b14610400576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103f790611046565b60405180910390fd5b60208161040d9190610f46565b866104189190610f46565b9550505b610492565b602089607f84168151811061043957610438610ec3565b5b60200260200101515114610482576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610479906110d4565b60405180910390fd5b60208561048f9190610f46565b94505b60208401935080600101905061030e565b506004846104b19190610f46565b67ffffffffffffffff8111156104ca576104c961069c565b5b6040519080825280601f01601f1916602001820160405280156104fc5781602001600182028036833780820191505090505b5094508660208601525f93505f5b60208110156106515786816020811061052657610525610ec3565b5b1a60f81b60f81c60ff16915060ff820315610651575f60808316146106115760fe820361059c57838560248801015261057c836020886004886105699190610f46565b6020885161057791906110f2565b61065d565b6020835161058a91906110f2565b846105959190610f46565b935061060c565b5f89607f8416815181106105b3576105b2610ec3565b5b602002602001015151905084866024890101526105fc8a607f8516815181106105df576105de610ec3565b5b60200260200101515f896004896105f69190610f46565b8561065d565b80856106089190610f46565b9450505b610640565b5f89607f84168151811061062857610627610ec3565b5b60200260200101519050602081015186602489010152505b60208501945080600101905061050a565b50505050509392505050565b808260208501018286602089010160045afa505050505050565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6106d28261068c565b810181811067ffffffffffffffff821117156106f1576106f061069c565b5b80604052505050565b5f610703610677565b905061070f82826106c9565b919050565b5f67ffffffffffffffff82111561072e5761072d61069c565b5b602082029050602081019050919050565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff8211156107615761076061069c565b5b61076a8261068c565b9050602081019050919050565b828183375f83830152505050565b5f61079761079284610747565b6106fa565b9050828152602081018484840111156107b3576107b2610743565b5b6107be848285610777565b509392505050565b5f82601f8301126107da576107d9610688565b5b81356107ea848260208601610785565b91505092915050565b5f61080561080084610714565b6106fa565b905080838252602082019050602084028301858111156108285761082761073f565b5b835b8181101561086f57803567ffffffffffffffff81111561084d5761084c610688565b5b80860161085a89826107c6565b8552602085019450505060208101905061082a565b5050509392505050565b5f82601f83011261088d5761088c610688565b5b813561089d8482602086016107f3565b91505092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b6108da816108a6565b81146108e4575f5ffd5b50565b5f813590506108f5816108d1565b92915050565b5f5f5f6060848603121561091257610911610680565b5b5f84013567ffffffffffffffff81111561092f5761092e610684565b5b61093b86828701610879565b935050602061094c868287016108e7565b925050604084013567ffffffffffffffff81111561096d5761096c610684565b5b610979868287016107c6565b9150509250925092565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f6109de826109ac565b6109e881856109b6565b93506109f88185602086016109c6565b610a018161068c565b840191505092915050565b5f610a1783836109d4565b905092915050565b5f602082019050919050565b5f610a3582610983565b610a3f818561098d565b935083602082028501610a518561099d565b805f5b85811015610a8c5784840389528151610a6d8582610a0c565b9450610a7883610a1f565b925060208a01995050600181019050610a54565b50829750879550505050505092915050565b5f82825260208201905092915050565b5f610ab8826109ac565b610ac28185610a9e565b9350610ad28185602086016109c6565b610adb8161068c565b840191505092915050565b5f6040820190508181035f830152610afe8185610a2b565b90508181036020830152610b128184610aae565b90509392505050565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b610b4f81610b1b565b8114610b59575f5ffd5b50565b5f81359050610b6a81610b46565b92915050565b5f819050919050565b610b8281610b70565b8114610b8c575f5ffd5b50565b5f81359050610b9d81610b79565b92915050565b5f5f5f60608486031215610bba57610bb9610680565b5b5f84013567ffffffffffffffff811115610bd757610bd6610684565b5b610be386828701610879565b9350506020610bf486828701610b5c565b9250506040610c0586828701610b8f565b9150509250925092565b5f6020820190508181035f830152610c278184610aae565b905092915050565b5f610c41610c3c84610747565b6106fa565b905082815260208101848484011115610c5d57610c5c610743565b5b610c688482856109c6565b509392505050565b5f82601f830112610c8457610c83610688565b5b8151610c94848260208601610c2f565b91505092915050565b5f610caf610caa84610714565b6106fa565b90508083825260208201905060208402830185811115610cd257610cd161073f565b5b835b81811015610d1957805167ffffffffffffffff811115610cf757610cf6610688565b5b808601610d048982610c70565b85526020850194505050602081019050610cd4565b5050509392505050565b5f82601f830112610d3757610d36610688565b5b8151610d47848260208601610c9d565b91505092915050565b5f60208284031215610d6557610d64610680565b5b5f82015167ffffffffffffffff811115610d8257610d81610684565b5b610d8e84828501610d23565b91505092915050565b5f82825260208201905092915050565b7f4f6e6c79206f6e652072657475726e2076616c7565207065726d6974746564205f8201527f287661726961626c652900000000000000000000000000000000000000000000602082015250565b5f610e01602a83610d97565b9150610e0c82610da7565b604082019050919050565b5f6020820190508181035f830152610e2e81610df5565b9050919050565b7f4f6e6c79206f6e652072657475726e2076616c7565207065726d6974746564205f8201527f2873746174696329000000000000000000000000000000000000000000000000602082015250565b5f610e8f602883610d97565b9150610e9a82610e35565b604082019050919050565b5f6020820190508181035f830152610ebc81610e83565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f6020820190508181035f830152610f088184610a2b565b905092915050565b5f819050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610f5082610f10565b9150610f5b83610f10565b9250828201905080821115610f7357610f72610f19565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f610fb082610f10565b9150610fbb83610f10565b925082610fcb57610fca610f79565b5b828206905092915050565b7f44796e616d6963207374617465207661726961626c6573206d757374206265205f8201527f61206d756c7469706c65206f6620333220627974657300000000000000000000602082015250565b5f611030603683610d97565b915061103b82610fd6565b604082019050919050565b5f6020820190508181035f83015261105d81611024565b9050919050565b7f537461746963207374617465207661726961626c6573206d75737420626520335f8201527f3220627974657300000000000000000000000000000000000000000000000000602082015250565b5f6110be602783610d97565b91506110c982611064565b604082019050919050565b5f6020820190508181035f8301526110eb816110b2565b9050919050565b5f6110fc82610f10565b915061110783610f10565b925082820390508181111561111f5761111e610f19565b5b9291505056fea26469706673582212200a468309572a2a135fa5515616f54534376474a0e8717dc15e60aead1284d59264736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0UW_5`\xE0\x1C\x80c\x17\x1F\x98\xCB\x14a\0YW\x80c\x7F\x18\x03!\x14a\0\x8AW\x80c\x7F\xF6\xF3O\x14a\0\xBBW\x80c\xA4\x02`\x9A\x14a\0\xEBW\x80c\xED\xFFI\xF7\x14a\x01\x1BW[__\xFD[a\0s`\x04\x806\x03\x81\x01\x90a\0n\x91\x90a\x08\xFBV[a\x01%V[`@Qa\0\x81\x92\x91\x90a\n\xE6V[`@Q\x80\x91\x03\x90\xF3[a\0\xA4`\x04\x806\x03\x81\x01\x90a\0\x9F\x91\x90a\x08\xFBV[a\x01MV[`@Qa\0\xB2\x92\x91\x90a\n\xE6V[`@Q\x80\x91\x03\x90\xF3[a\0\xD5`\x04\x806\x03\x81\x01\x90a\0\xD0\x91\x90a\x0B\xA3V[a\x01\xABV[`@Qa\0\xE2\x91\x90a\x0C\x0FV[`@Q\x80\x91\x03\x90\xF3[a\x01\x05`\x04\x806\x03\x81\x01\x90a\x01\0\x91\x90a\x0B\xA3V[a\x01\xD0V[`@Qa\x01\x12\x91\x90a\x0C\x0FV[`@Q\x80\x91\x03\x90\xF3[a\x01#a\x01\xD9V[\0[``\x80a\x01=\x84\x84\x87a\x01\xDB\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x94P\x84\x83\x91P\x91P\x93P\x93\x91PPV[``\x80\x84` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x01lWa\x01ka\x06\x9CV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x01\x9EW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x91P\x91P\x93P\x93\x91PPV[``_a\x01\xC3\x84\x84\x87a\x03\x05\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x90P\x80\x91PP\x93\x92PPPV[``\x93\x92PPPV[V[``_\x83`\xF8\x1C`\xFF\x16\x90P`\xFF\x81\x03a\x01\xF8W\x84\x91PPa\x02\xFEV[_`\x80\x82\x16\x14a\x02\x92W`\xFE\x81\x03a\x02%W\x82\x80` \x01\x90Q\x81\x01\x90a\x02\x1E\x91\x90a\rPV[\x94Pa\x02\x8DV[_` \x84\x01Q\x90P` \x81\x14a\x02pW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02g\x90a\x0E\x17V[`@Q\x80\x91\x03\x90\xFD[` \x84Q\x03` \x85\x01R` \x84\x01` `\x7F\x84\x16\x02` \x88\x01\x01RP[a\x02\xF9V[` \x83Q\x14a\x02\xD6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02\xCD\x90a\x0E\xA5V[`@Q\x80\x91\x03\x90\xFD[\x82\x85`\x7F\x83\x16\x81Q\x81\x10a\x02\xEDWa\x02\xECa\x0E\xC3V[[` \x02` \x01\x01\x81\x90RP[\x84\x91PP[\x93\x92PPPV[``__``__[` \x81\x10\x15a\x04\xA3W\x86\x81` \x81\x10a\x03*Wa\x03)a\x0E\xC3V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16\x91P`\xFF\x82\x03\x15a\x04\xA3W_`\x80\x83\x16\x14a\x04!W`\xFE\x82\x03a\x03\x90W_\x83Q\x03a\x03|W\x88`@Q` \x01a\x03j\x91\x90a\x0E\xF0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x92P[\x82Q\x85a\x03\x89\x91\x90a\x0FFV[\x94Pa\x04\x1CV[_\x89`\x7F\x84\x16\x81Q\x81\x10a\x03\xA7Wa\x03\xA6a\x0E\xC3V[[` \x02` \x01\x01QQ\x90P_` \x82a\x03\xC0\x91\x90a\x0F\xA6V[\x14a\x04\0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03\xF7\x90a\x10FV[`@Q\x80\x91\x03\x90\xFD[` \x81a\x04\r\x91\x90a\x0FFV[\x86a\x04\x18\x91\x90a\x0FFV[\x95PP[a\x04\x92V[` \x89`\x7F\x84\x16\x81Q\x81\x10a\x049Wa\x048a\x0E\xC3V[[` \x02` \x01\x01QQ\x14a\x04\x82W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04y\x90a\x10\xD4V[`@Q\x80\x91\x03\x90\xFD[` \x85a\x04\x8F\x91\x90a\x0FFV[\x94P[` \x84\x01\x93P\x80`\x01\x01\x90Pa\x03\x0EV[P`\x04\x84a\x04\xB1\x91\x90a\x0FFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x04\xCAWa\x04\xC9a\x06\x9CV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x04\xFCW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x94P\x86` \x86\x01R_\x93P_[` \x81\x10\x15a\x06QW\x86\x81` \x81\x10a\x05&Wa\x05%a\x0E\xC3V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16\x91P`\xFF\x82\x03\x15a\x06QW_`\x80\x83\x16\x14a\x06\x11W`\xFE\x82\x03a\x05\x9CW\x83\x85`$\x88\x01\x01Ra\x05|\x83` \x88`\x04\x88a\x05i\x91\x90a\x0FFV[` \x88Qa\x05w\x91\x90a\x10\xF2V[a\x06]V[` \x83Qa\x05\x8A\x91\x90a\x10\xF2V[\x84a\x05\x95\x91\x90a\x0FFV[\x93Pa\x06\x0CV[_\x89`\x7F\x84\x16\x81Q\x81\x10a\x05\xB3Wa\x05\xB2a\x0E\xC3V[[` \x02` \x01\x01QQ\x90P\x84\x86`$\x89\x01\x01Ra\x05\xFC\x8A`\x7F\x85\x16\x81Q\x81\x10a\x05\xDFWa\x05\xDEa\x0E\xC3V[[` \x02` \x01\x01Q_\x89`\x04\x89a\x05\xF6\x91\x90a\x0FFV[\x85a\x06]V[\x80\x85a\x06\x08\x91\x90a\x0FFV[\x94PP[a\x06@V[_\x89`\x7F\x84\x16\x81Q\x81\x10a\x06(Wa\x06'a\x0E\xC3V[[` \x02` \x01\x01Q\x90P` \x81\x01Q\x86`$\x89\x01\x01RP[` \x85\x01\x94P\x80`\x01\x01\x90Pa\x05\nV[PPPPP\x93\x92PPPV[\x80\x82` \x85\x01\x01\x82\x86` \x89\x01\x01`\x04Z\xFAPPPPPPV[_`@Q\x90P\x90V[__\xFD[__\xFD[__\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x06\xD2\x82a\x06\x8CV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x06\xF1Wa\x06\xF0a\x06\x9CV[[\x80`@RPPPV[_a\x07\x03a\x06wV[\x90Pa\x07\x0F\x82\x82a\x06\xC9V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x07.Wa\x07-a\x06\x9CV[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x07aWa\x07`a\x06\x9CV[[a\x07j\x82a\x06\x8CV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a\x07\x97a\x07\x92\x84a\x07GV[a\x06\xFAV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a\x07\xB3Wa\x07\xB2a\x07CV[[a\x07\xBE\x84\x82\x85a\x07wV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x07\xDAWa\x07\xD9a\x06\x88V[[\x815a\x07\xEA\x84\x82` \x86\x01a\x07\x85V[\x91PP\x92\x91PPV[_a\x08\x05a\x08\0\x84a\x07\x14V[a\x06\xFAV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x08(Wa\x08'a\x07?V[[\x83[\x81\x81\x10\x15a\x08oW\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x08MWa\x08La\x06\x88V[[\x80\x86\x01a\x08Z\x89\x82a\x07\xC6V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa\x08*V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x08\x8DWa\x08\x8Ca\x06\x88V[[\x815a\x08\x9D\x84\x82` \x86\x01a\x07\xF3V[\x91PP\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a\x08\xDA\x81a\x08\xA6V[\x81\x14a\x08\xE4W__\xFD[PV[_\x815\x90Pa\x08\xF5\x81a\x08\xD1V[\x92\x91PPV[___``\x84\x86\x03\x12\x15a\t\x12Wa\t\x11a\x06\x80V[[_\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\t/Wa\t.a\x06\x84V[[a\t;\x86\x82\x87\x01a\x08yV[\x93PP` a\tL\x86\x82\x87\x01a\x08\xE7V[\x92PP`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\tmWa\tla\x06\x84V[[a\ty\x86\x82\x87\x01a\x07\xC6V[\x91PP\x92P\x92P\x92V[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_a\t\xDE\x82a\t\xACV[a\t\xE8\x81\x85a\t\xB6V[\x93Pa\t\xF8\x81\x85` \x86\x01a\t\xC6V[a\n\x01\x81a\x06\x8CV[\x84\x01\x91PP\x92\x91PPV[_a\n\x17\x83\x83a\t\xD4V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\n5\x82a\t\x83V[a\n?\x81\x85a\t\x8DV[\x93P\x83` \x82\x02\x85\x01a\nQ\x85a\t\x9DV[\x80_[\x85\x81\x10\x15a\n\x8CW\x84\x84\x03\x89R\x81Qa\nm\x85\x82a\n\x0CV[\x94Pa\nx\x83a\n\x1FV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pa\nTV[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a\n\xB8\x82a\t\xACV[a\n\xC2\x81\x85a\n\x9EV[\x93Pa\n\xD2\x81\x85` \x86\x01a\t\xC6V[a\n\xDB\x81a\x06\x8CV[\x84\x01\x91PP\x92\x91PPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ra\n\xFE\x81\x85a\n+V[\x90P\x81\x81\x03` \x83\x01Ra\x0B\x12\x81\x84a\n\xAEV[\x90P\x93\x92PPPV[_\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a\x0BO\x81a\x0B\x1BV[\x81\x14a\x0BYW__\xFD[PV[_\x815\x90Pa\x0Bj\x81a\x0BFV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x0B\x82\x81a\x0BpV[\x81\x14a\x0B\x8CW__\xFD[PV[_\x815\x90Pa\x0B\x9D\x81a\x0ByV[\x92\x91PPV[___``\x84\x86\x03\x12\x15a\x0B\xBAWa\x0B\xB9a\x06\x80V[[_\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0B\xD7Wa\x0B\xD6a\x06\x84V[[a\x0B\xE3\x86\x82\x87\x01a\x08yV[\x93PP` a\x0B\xF4\x86\x82\x87\x01a\x0B\\V[\x92PP`@a\x0C\x05\x86\x82\x87\x01a\x0B\x8FV[\x91PP\x92P\x92P\x92V[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0C'\x81\x84a\n\xAEV[\x90P\x92\x91PPV[_a\x0CAa\x0C<\x84a\x07GV[a\x06\xFAV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a\x0C]Wa\x0C\\a\x07CV[[a\x0Ch\x84\x82\x85a\t\xC6V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x0C\x84Wa\x0C\x83a\x06\x88V[[\x81Qa\x0C\x94\x84\x82` \x86\x01a\x0C/V[\x91PP\x92\x91PPV[_a\x0C\xAFa\x0C\xAA\x84a\x07\x14V[a\x06\xFAV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x0C\xD2Wa\x0C\xD1a\x07?V[[\x83[\x81\x81\x10\x15a\r\x19W\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C\xF7Wa\x0C\xF6a\x06\x88V[[\x80\x86\x01a\r\x04\x89\x82a\x0CpV[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa\x0C\xD4V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\r7Wa\r6a\x06\x88V[[\x81Qa\rG\x84\x82` \x86\x01a\x0C\x9DV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a\reWa\rda\x06\x80V[[_\x82\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\x82Wa\r\x81a\x06\x84V[[a\r\x8E\x84\x82\x85\x01a\r#V[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOnly one return value permitted _\x82\x01R\x7F(variable)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0E\x01`*\x83a\r\x97V[\x91Pa\x0E\x0C\x82a\r\xA7V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0E.\x81a\r\xF5V[\x90P\x91\x90PV[\x7FOnly one return value permitted _\x82\x01R\x7F(static)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0E\x8F`(\x83a\r\x97V[\x91Pa\x0E\x9A\x82a\x0E5V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0E\xBC\x81a\x0E\x83V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0F\x08\x81\x84a\n+V[\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x0FP\x82a\x0F\x10V[\x91Pa\x0F[\x83a\x0F\x10V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\x0FsWa\x0Fra\x0F\x19V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a\x0F\xB0\x82a\x0F\x10V[\x91Pa\x0F\xBB\x83a\x0F\x10V[\x92P\x82a\x0F\xCBWa\x0F\xCAa\x0FyV[[\x82\x82\x06\x90P\x92\x91PPV[\x7FDynamic state variables must be _\x82\x01R\x7Fa multiple of 32 bytes\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x100`6\x83a\r\x97V[\x91Pa\x10;\x82a\x0F\xD6V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x10]\x81a\x10$V[\x90P\x91\x90PV[\x7FStatic state variables must be 3_\x82\x01R\x7F2 bytes\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x10\xBE`'\x83a\r\x97V[\x91Pa\x10\xC9\x82a\x10dV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x10\xEB\x81a\x10\xB2V[\x90P\x91\x90PV[_a\x10\xFC\x82a\x0F\x10V[\x91Pa\x11\x07\x83a\x0F\x10V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a\x11\x1FWa\x11\x1Ea\x0F\x19V[[\x92\x91PPV\xFE\xA2dipfsX\"\x12 \nF\x83\tW**\x13_\xA5QV\x16\xF5E47dt\xA0\xE8q}\xC1^`\xAE\xAD\x12\x84\xD5\x92dsolcC\0\x08\x1E\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `basecall()` and selector `0xedff49f7`.
    ```solidity
    function basecall() external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct basecallCall;
    ///Container type for the return parameters of the [`basecall()`](basecallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct basecallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<basecallCall> for UnderlyingRustTuple<'_> {
                fn from(value: basecallCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for basecallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<basecallReturn> for UnderlyingRustTuple<'_> {
                fn from(value: basecallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for basecallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl basecallReturn {
            fn _tokenize(&self) -> <basecallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for basecallCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = basecallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "basecall()";
            const SELECTOR: [u8; 4] = [237u8, 255u8, 73u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                basecallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(
                    data,
                )
                .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `testBuildInputs(bytes[],bytes4,bytes32)` and selector `0x7ff6f34f`.
    ```solidity
    function testBuildInputs(bytes[] memory state, bytes4 selector, bytes32 indices) external view returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testBuildInputsCall {
        #[allow(missing_docs)]
        pub state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        #[allow(missing_docs)]
        pub selector: alloy::sol_types::private::FixedBytes<4>,
        #[allow(missing_docs)]
        pub indices: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`testBuildInputs(bytes[],bytes4,bytes32)`](testBuildInputsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testBuildInputsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::FixedBytes<4>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testBuildInputsCall> for UnderlyingRustTuple<'_> {
                fn from(value: testBuildInputsCall) -> Self {
                    (value.state, value.selector, value.indices)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testBuildInputsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        state: tuple.0,
                        selector: tuple.1,
                        indices: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testBuildInputsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testBuildInputsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testBuildInputsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testBuildInputsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testBuildInputs(bytes[],bytes4,bytes32)";
            const SELECTOR: [u8; 4] = [127u8, 246u8, 243u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.state),
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.selector),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.indices),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(
                    |r| {
                        let r: testBuildInputsReturn = r.into();
                        r._0
                    },
                )
            }
            #[inline]
            fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(
                    data,
                )
                .map(|r| {
                    let r: testBuildInputsReturn = r.into();
                    r._0
                })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `testBuildInputsBaseGas(bytes[],bytes4,bytes32)` and selector `0xa402609a`.
    ```solidity
    function testBuildInputsBaseGas(bytes[] memory state, bytes4 selector, bytes32 indices) external view returns (bytes memory out);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testBuildInputsBaseGasCall {
        #[allow(missing_docs)]
        pub state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        #[allow(missing_docs)]
        pub selector: alloy::sol_types::private::FixedBytes<4>,
        #[allow(missing_docs)]
        pub indices: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`testBuildInputsBaseGas(bytes[],bytes4,bytes32)`](testBuildInputsBaseGasCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testBuildInputsBaseGasReturn {
        #[allow(missing_docs)]
        pub out: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::FixedBytes<4>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testBuildInputsBaseGasCall> for UnderlyingRustTuple<'_> {
                fn from(value: testBuildInputsBaseGasCall) -> Self {
                    (value.state, value.selector, value.indices)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testBuildInputsBaseGasCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        state: tuple.0,
                        selector: tuple.1,
                        indices: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testBuildInputsBaseGasReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testBuildInputsBaseGasReturn) -> Self {
                    (value.out,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testBuildInputsBaseGasReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { out: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testBuildInputsBaseGasCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testBuildInputsBaseGas(bytes[],bytes4,bytes32)";
            const SELECTOR: [u8; 4] = [164u8, 2u8, 96u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.state),
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.selector),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.indices),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(
                    |r| {
                        let r: testBuildInputsBaseGasReturn = r.into();
                        r.out
                    },
                )
            }
            #[inline]
            fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(
                    data,
                )
                .map(|r| {
                    let r: testBuildInputsBaseGasReturn = r.into();
                    r.out
                })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `testWriteOutputs(bytes[],bytes1,bytes)` and selector `0x171f98cb`.
    ```solidity
    function testWriteOutputs(bytes[] memory state, bytes1 index, bytes memory output) external pure returns (bytes[] memory, bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testWriteOutputsCall {
        #[allow(missing_docs)]
        pub state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub output: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`testWriteOutputs(bytes[],bytes1,bytes)`](testWriteOutputsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testWriteOutputsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testWriteOutputsCall> for UnderlyingRustTuple<'_> {
                fn from(value: testWriteOutputsCall) -> Self {
                    (value.state, value.index, value.output)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testWriteOutputsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        state: tuple.0,
                        index: tuple.1,
                        output: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testWriteOutputsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testWriteOutputsReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testWriteOutputsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        impl testWriteOutputsReturn {
            fn _tokenize(
                &self,
            ) -> <testWriteOutputsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testWriteOutputsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testWriteOutputsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testWriteOutputs(bytes[],bytes1,bytes)";
            const SELECTOR: [u8; 4] = [23u8, 31u8, 152u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.state),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.output,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                testWriteOutputsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(
                    data,
                )
                .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `testWriteOutputsBaseGas(bytes[],bytes1,bytes)` and selector `0x7f180321`.
    ```solidity
    function testWriteOutputsBaseGas(bytes[] memory state, bytes1 index, bytes memory output) external pure returns (bytes[] memory, bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testWriteOutputsBaseGasCall {
        #[allow(missing_docs)]
        pub state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub output: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`testWriteOutputsBaseGas(bytes[],bytes1,bytes)`](testWriteOutputsBaseGasCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testWriteOutputsBaseGasReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testWriteOutputsBaseGasCall> for UnderlyingRustTuple<'_> {
                fn from(value: testWriteOutputsBaseGasCall) -> Self {
                    (value.state, value.index, value.output)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testWriteOutputsBaseGasCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        state: tuple.0,
                        index: tuple.1,
                        output: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testWriteOutputsBaseGasReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testWriteOutputsBaseGasReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testWriteOutputsBaseGasReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        impl testWriteOutputsBaseGasReturn {
            fn _tokenize(
                &self,
            ) -> <testWriteOutputsBaseGasCall as alloy_sol_types::SolCall>::ReturnToken<'_>
            {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testWriteOutputsBaseGasCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testWriteOutputsBaseGasReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testWriteOutputsBaseGas(bytes[],bytes1,bytes)";
            const SELECTOR: [u8; 4] = [127u8, 24u8, 3u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.state),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.output,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                testWriteOutputsBaseGasReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(
                    data,
                )
                .map(Into::into)
            }
        }
    };
    ///Container for all the [`CommandBuilderHarness`](self) function calls.
    #[derive(Clone, serde::Serialize, serde::Deserialize)]
    pub enum CommandBuilderHarnessCalls {
        #[allow(missing_docs)]
        basecall(basecallCall),
        #[allow(missing_docs)]
        testBuildInputs(testBuildInputsCall),
        #[allow(missing_docs)]
        testBuildInputsBaseGas(testBuildInputsBaseGasCall),
        #[allow(missing_docs)]
        testWriteOutputs(testWriteOutputsCall),
        #[allow(missing_docs)]
        testWriteOutputsBaseGas(testWriteOutputsBaseGasCall),
    }
    impl CommandBuilderHarnessCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [23u8, 31u8, 152u8, 203u8],
            [127u8, 24u8, 3u8, 33u8],
            [127u8, 246u8, 243u8, 79u8],
            [164u8, 2u8, 96u8, 154u8],
            [237u8, 255u8, 73u8, 247u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(testWriteOutputs),
            ::core::stringify!(testWriteOutputsBaseGas),
            ::core::stringify!(testBuildInputs),
            ::core::stringify!(testBuildInputsBaseGas),
            ::core::stringify!(basecall),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <testWriteOutputsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <testWriteOutputsBaseGasCall as alloy_sol_types::SolCall>::SIGNATURE,
            <testBuildInputsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <testBuildInputsBaseGasCall as alloy_sol_types::SolCall>::SIGNATURE,
            <basecallCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(selector: [u8; 4usize]) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for CommandBuilderHarnessCalls {
        const NAME: &'static str = "CommandBuilderHarnessCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 5usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::basecall(_) => <basecallCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testBuildInputs(_) => {
                    <testBuildInputsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::testBuildInputsBaseGas(_) => {
                    <testBuildInputsBaseGasCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::testWriteOutputs(_) => {
                    <testWriteOutputsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::testWriteOutputsBaseGas(_) => {
                    <testWriteOutputsBaseGasCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(selector: [u8; 4], data: &[u8]) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            )
                -> alloy_sol_types::Result<CommandBuilderHarnessCalls>] = &[
                {
                    fn testWriteOutputs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testWriteOutputsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(CommandBuilderHarnessCalls::testWriteOutputs)
                    }
                    testWriteOutputs
                },
                {
                    fn testWriteOutputsBaseGas(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testWriteOutputsBaseGasCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data,
                        )
                        .map(CommandBuilderHarnessCalls::testWriteOutputsBaseGas)
                    }
                    testWriteOutputsBaseGas
                },
                {
                    fn testBuildInputs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testBuildInputsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(CommandBuilderHarnessCalls::testBuildInputs)
                    }
                    testBuildInputs
                },
                {
                    fn testBuildInputsBaseGas(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testBuildInputsBaseGasCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data,
                        )
                        .map(CommandBuilderHarnessCalls::testBuildInputsBaseGas)
                    }
                    testBuildInputsBaseGas
                },
                {
                    fn basecall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <basecallCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(CommandBuilderHarnessCalls::basecall)
                    }
                    basecall
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<
                CommandBuilderHarnessCalls,
            >] = &[
                {
                    fn testWriteOutputs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testWriteOutputsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                            data,
                        )
                        .map(CommandBuilderHarnessCalls::testWriteOutputs)
                    }
                    testWriteOutputs
                },
                {
                    fn testWriteOutputsBaseGas(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testWriteOutputsBaseGasCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(CommandBuilderHarnessCalls::testWriteOutputsBaseGas)
                    }
                    testWriteOutputsBaseGas
                },
                {
                    fn testBuildInputs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testBuildInputsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                            data,
                        )
                        .map(CommandBuilderHarnessCalls::testBuildInputs)
                    }
                    testBuildInputs
                },
                {
                    fn testBuildInputsBaseGas(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <testBuildInputsBaseGasCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(CommandBuilderHarnessCalls::testBuildInputsBaseGas)
                    }
                    testBuildInputsBaseGas
                },
                {
                    fn basecall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<CommandBuilderHarnessCalls> {
                        <basecallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
                            .map(CommandBuilderHarnessCalls::basecall)
                    }
                    basecall
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::basecall(inner) => {
                    <basecallCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testBuildInputs(inner) => {
                    <testBuildInputsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testBuildInputsBaseGas(inner) => {
                    <testBuildInputsBaseGasCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::testWriteOutputs(inner) => {
                    <testWriteOutputsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testWriteOutputsBaseGas(inner) => {
                    <testWriteOutputsBaseGasCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::basecall(inner) => {
                    <basecallCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testBuildInputs(inner) => {
                    <testBuildInputsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testBuildInputsBaseGas(inner) => {
                    <testBuildInputsBaseGasCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::testWriteOutputs(inner) => {
                    <testWriteOutputsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testWriteOutputsBaseGas(inner) => {
                    <testWriteOutputsBaseGasCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`CommandBuilderHarness`](self) contract instance.

    See the [wrapper's documentation](`CommandBuilderHarnessInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> CommandBuilderHarnessInstance<P, N> {
        CommandBuilderHarnessInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

    Returns a new instance of the contract, if the deployment was successful.

    For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
        __provider: P,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<CommandBuilderHarnessInstance<P, N>>>
    {
        CommandBuilderHarnessInstance::<P, N>::deploy(__provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
    and constructor arguments, if any.

    This is a simple wrapper around creating a `RawCallBuilder` with the data set to
    the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        CommandBuilderHarnessInstance::<P, N>::deploy_builder(__provider)
    }
    /**A [`CommandBuilderHarness`](self) instance.

    Contains type-safe methods for interacting with an on-chain instance of the
    [`CommandBuilderHarness`](self) contract located at a given `address`, using a given
    provider `P`.

    If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
    documentation on how to provide it), the `deploy` and `deploy_builder` methods can
    be used to deploy a new instance of the contract.

    See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct CommandBuilderHarnessInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for CommandBuilderHarnessInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("CommandBuilderHarnessInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>
        CommandBuilderHarnessInstance<P, N>
    {
        /**Creates a new wrapper around an on-chain [`CommandBuilderHarness`](self) contract instance.

        See the [wrapper's documentation](`CommandBuilderHarnessInstance`) for more details.*/
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, __provider: P) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

        Returns a new instance of the contract, if the deployment was successful.

        For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
        ) -> alloy_contract::Result<CommandBuilderHarnessInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
        and constructor arguments, if any.

        This is a simple wrapper around creating a `RawCallBuilder` with the data set to
        the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> CommandBuilderHarnessInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> CommandBuilderHarnessInstance<P, N> {
            CommandBuilderHarnessInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>
        CommandBuilderHarnessInstance<P, N>
    {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`basecall`] function.
        pub fn basecall(&self) -> alloy_contract::SolCallBuilder<&P, basecallCall, N> {
            self.call_builder(&basecallCall)
        }
        ///Creates a new call builder for the [`testBuildInputs`] function.
        pub fn testBuildInputs(
            &self,
            state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            selector: alloy::sol_types::private::FixedBytes<4>,
            indices: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, testBuildInputsCall, N> {
            self.call_builder(&testBuildInputsCall {
                state,
                selector,
                indices,
            })
        }
        ///Creates a new call builder for the [`testBuildInputsBaseGas`] function.
        pub fn testBuildInputsBaseGas(
            &self,
            state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            selector: alloy::sol_types::private::FixedBytes<4>,
            indices: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, testBuildInputsBaseGasCall, N> {
            self.call_builder(&testBuildInputsBaseGasCall {
                state,
                selector,
                indices,
            })
        }
        ///Creates a new call builder for the [`testWriteOutputs`] function.
        pub fn testWriteOutputs(
            &self,
            state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            index: alloy::sol_types::private::FixedBytes<1>,
            output: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, testWriteOutputsCall, N> {
            self.call_builder(&testWriteOutputsCall {
                state,
                index,
                output,
            })
        }
        ///Creates a new call builder for the [`testWriteOutputsBaseGas`] function.
        pub fn testWriteOutputsBaseGas(
            &self,
            state: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            index: alloy::sol_types::private::FixedBytes<1>,
            output: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, testWriteOutputsBaseGasCall, N> {
            self.call_builder(&testWriteOutputsBaseGasCall {
                state,
                index,
                output,
            })
        }
    }
    /// Event filters.
    impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>
        CommandBuilderHarnessInstance<P, N>
    {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
